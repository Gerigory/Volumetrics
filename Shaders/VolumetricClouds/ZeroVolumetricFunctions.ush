#pragma once

#define NumShadowSteps 16
#define Episilon 1e-3

// find the intersection distance from camera of 
// ray direction with sphere with radius = inRadius
// @ float3 RO: Ray Origin -> Camera Pos From Planet Center
// @ float3 RD: revert of Camera Look At Dir
// @ float inRadius, Radius of Planet
// @ float SceneDepth, Current Pixel's Depth
float3 SphereIntersection(float3 RO, float3 RD, float inRadius, float SceneDepth)
{
	float B = dot(RD, RO);
	float C = dot(RO, RO) - inRadius * inRadius;

	// binomial root 
	float t0 = -B - sqrt(B * B - C);
	float t1 = -B + sqrt(B * B - C);
	
	//intersection with backward position, make it zero
	t0 = max(t0, 0);
	//intersection with a object, make it stop at the position
	t1 =(t1 > 0) ? min(t1, SceneDepth) : t1;

	return float3(t0, t1, max(0, t1 - t0));
}

float2 GetCloudIntersection(float EarthRadius, float2 inCloudMinMax, float3 RayOrigin, float3 RayDirection, float SceneDepth)
{
	float CloudLayerAltitude = inCloudMinMax.x;
	float CloudLayerThickness = inCloudMinMax.y - inCloudMinMax.x;

	float LayerABottom = EarthRadius + CloudLayerAltitude;
	float LayerATop = LayerABottom + CloudLayerThickness;
	
	float3 PlanetOuter = SphereIntersection(RayOrigin, RayDirection, EarthRadius, SceneDepth);
	
	//Use Planetary Distance beyond depth precision limits
	if (SceneDepth > 650000 && PlanetOuter.x > Episilon)
	{
		SceneDepth = PlanetOuter.x;
	}
	
	float3 LayerAOuter = SphereIntersection(RayOrigin, RayDirection, LayerATop, SceneDepth);
	float3 LayerAInner = SphereIntersection(RayOrigin, RayDirection, LayerABottom, SceneDepth);
	
	float cloudentry = LayerAOuter.x;
	float cloudexit = LayerAOuter.y;
	
	//extract rays that exit and re-enter the cloud layer
	//Is Camera outisde the Inner Cloud layer
	float mask = (LayerAInner.x > Episilon) ? 1 : 0;
	//ignore rays that hit the planet surface
	mask *= (PlanetOuter.x > Episilon) ? 0 : 1;
	
	//Ray exits and re-enters, stop the initial ray at that first exit spot, so we can skip empty space inbetween easily
	if (mask == 1)
	{
		cloudexit = min(LayerAInner.x, SceneDepth);
	}

	
	// Ray Hits the Inner Shell of Cloud layer
	if (LayerAInner.z > 0)
	{
		cloudexit = min(LayerAInner.x, SceneDepth);
	}
	
	//Camera is inside the bottom/inner cloud radius, advacnce ray to inner shell
	if (LayerAInner.x < Episilon && LayerAInner.z > Episilon)
	{
		cloudentry = LayerAInner.y;
		cloudexit = LayerAOuter.y;
	}

	return float2(cloudentry, cloudexit);
}

// Utility function that maps a value from one range to another .
float Remap(float original_value , float original_min, float original_max , float new_min , float new_max)
{
	return new_min +(((original_value - original_min) /(original_max - original_min)) *(new_max - new_min));
}

// Fractional value for sample position in the cloud layer .
float GetHeightFractionForPoint(float3 inPosition, float4 inCloudMinMax)
{
	// Get global fractional position in cloud zone .
	float HeightFraction =(inPosition.z / 1000.0f - inCloudMinMax.x) /(inCloudMinMax.y - inCloudMinMax.x);
	return saturate(HeightFraction);
}

// Get The Mip Level of Cloud Shape Texture(PWNoiseTex)
// @ float RayDistance, Distance of Intersection Point From Camera of Current Ray 
// @ float TanHalfFOV, 
// @ float RepeatSize, 
// @ float VolumeResolution, Cloud Shape Texture Resolution
// @ float2 ViewSize, Screen Size
float GetMipLevel(float RayDistance, float TanHalfFOV, float RepeatSize, float VolumeResolution, float2 ViewSize)
{
	float TexelsPerPixel =((RayDistance * TanHalfFOV * 2) / RepeatSize) *(VolumeResolution / max(ViewSize.x, ViewSize.y));
	return max(0, log2(TexelsPerPixel));
}

float3 ComponentIndexArray[3] = 
{
	float3(1, 0, 0),
	float3(0, 1, 0),
	float3(0, 0, 1)
};

float GetDensityHeightGradientForPoint(float HeightFraction, float3 WeatherData, Texture2D HeightLUTTex,  SamplerState HeightLUTTexSampler)
{
	float3 HeightLUT = HeightLUTTex.SampleLevel(HeightLUTTexSampler, float2(0, HeightFraction), 0).rgb;
	int CloudType = round(WeatherData.b * 2);// 0 for stratus, 2 for cumulous, 1 for stratucumulous
	return dot(ComponentIndexArray[CloudType], HeightLUT);
}

float3 GetSampleUVW(float3 pos, float4 inCloudMinMax)
{
	float3 PosInKm = pos / 1000.0f;
	float3 PWNoiseUVW = (PosInKm + float3(inCloudMinMax.z, inCloudMinMax.z, -inCloudMinMax.x)) / float3(inCloudMinMax.z * 2, inCloudMinMax.z * 2, inCloudMinMax.y - inCloudMinMax.x);
	return saturate(PWNoiseUVW);
}


float SampleCloudDensity(
	float3 pos, 
	float DensityScale,
	float4 inCloudMinMax, 
	int iTime, 
	float3 WeatherData, 
	float MipLevel,
	bool SampleUsingCheapWay,
	Texture3D PWNoiseTex,  
	SamplerState PWNoiseTexSampler,
	Texture2D CurlNoiseTex,  
	SamplerState CurlNoiseTexSampler,
	Texture2D HeightLUTTex,  
	SamplerState HeightLUTTexSampler
	)
{
	// Get the height fraction for use with blending noise types over height .
	float HeightFraction = GetHeightFractionForPoint(pos, inCloudMinMax);

	// Wind Simulation -----------------------------------------
	{
		// Wind settings .
		float3 wind_direction = float3(1.0 , 0.0 , 0.0);
		float cloud_speed = 10.0;

		// cloud top offset pushes the tops of the clouds along
		// this wind direction by this many units .
		float cloud_top_offset = 500.0;

		// Skew in wind direction .
		pos += HeightFraction * wind_direction * cloud_top_offset ;

		// Animate clouds in wind direction and add a small upward bias to the wind direction .
		pos +=(wind_direction + float3(0.0 , 0.1 , 0.0)) * iTime * cloud_speed;
	}


	// Base Cloud Modeling -----------------------------------------

	// Read the low-frequency Perlin-Worley and Worley noises .
	float3 PWNoiseUVW = GetSampleUVW(pos, inCloudMinMax);
	float2 PWNoise = PWNoiseTex.SampleLevel(PWNoiseTexSampler, PWNoiseUVW, MipLevel).rg;

	// Build an FBM out of the low frequency Worley noises  that can be used to add detail to the 
	// low-frequency Perlin-Worley noise .
	float low_freq_FBM = PWNoise.g;

	// define the base cloud shape by dilating it with the
	// low-frequency FBM made of Worley noise.
	float BaseCloud = Remap(PWNoise.r, -(1.0 - low_freq_FBM) , 1.0 , 0.0 , 1.0);

	// Get the density-height gradient using the density height
	// function explained in Section 2.2 .
	float DensityHeightGradient = GetDensityHeightGradientForPoint(HeightFraction, WeatherData, HeightLUTTex,  HeightLUTTexSampler);

	// Apply the height function to the base cloud shape .
	BaseCloud *= DensityHeightGradient;


	// Base Cloud Coverage Tunning -----------------------------------------

	// Cloud coverage is stored in weather data’s red channel .
	float cloud_coverage = WeatherData.r;

	// Use remap to apply the cloud coverage a tt r ibu t e .
	float BaseCloudWithCoverage = Remap(BaseCloud, cloud_coverage , 1.0 , 0.0 , 1.0);

	// Multiply the result by the cloud coverage attribute so
	// that smaller clouds are lighter and more aesthetically pleasing .
	BaseCloudWithCoverage *= cloud_coverage;

	// Cloud Detail Add -----------------------------------------
	if(!SampleUsingCheapWay)
	{	
		// curl noise sampling
		float2 CurlNoise = CurlNoiseTex.SampleLevel(CurlNoiseTexSampler, PWNoiseUVW.xy, 0).rg;

		// Add some turbulence to bottoms of clouds .
		pos.xy += CurlNoise * (1.0 - HeightFraction);

		PWNoiseUVW = GetSampleUVW(pos, inCloudMinMax);
		// Sample high-frequency noises .
		float HighFreqFBM = PWNoiseTex.SampleLevel(PWNoiseTexSampler, PWNoiseUVW * 0.1 , MipLevel).b;

		// Transition from wispy shapes to billowy shapes over height .
		float high_freq_noise_modifier = lerp(HighFreqFBM, 1.0 - HighFreqFBM , saturate(HeightFraction * 10.0));

		// Erode the base cloud shape with the distorted high-frequency Worley noises .
		float final_cloud = Remap(BaseCloudWithCoverage, high_freq_noise_modifier * 0.2 , 1.0 , 0.0 , 1.0);

		return final_cloud * DensityScale;
	}
	else
	{
		return BaseCloudWithCoverage * DensityScale;
	}
	
}

float HenyeyGreenstein(float3 inLightVector, float3 inViewVector , float inG)
{
	float CosAngle = dot(normalize(inLightVector), normalize(inViewVector));
	return((1.0 - inG * inG) / pow((1.0 + inG * inG - 2.0 * inG * CosAngle) , 3.0 / 2.0)) / 4.0 * 3.1415;
}

float GetLightTransmittance(float LightSamples)
{
	LightSamples = max(0.0f, LightSamples);
	float PowderSugerEffect = 1.0 - exp(-LightSamples * 2.0);

	float BeersLaw = exp (-LightSamples);

	float LightEnergy = 2.0 * BeersLaw * PowderSugerEffect;

	return LightEnergy;
}

static float3 noise_kernel [7] =
{
	float3(0.25387, -1.24151, -0.65258),
	float3(-1.63962, -0.77099, 0.20001),
	float3(-0.45732, -0.11479,  0.87494),
	float3(0.22146,  0.49370, -0.29963),
	float3(-0.91753, -1.92875,  0.49722),
	float3(-0.65509,  0.60337,  0.95802),
	float3(-0.65509,  0.60337,  0.95802),
};

// A function to gather density in a cone for use with lighting clouds .
float SampleCloudDensityAlongCone(
	float3 pos, 
	float DensityScale,
	float LightStepSize,
	float3 LightDirection,
	float4 inCloudMinMax, 
	int iTime, 
	float3 WeatherData, 
	float MipLevel,
	Texture3D PWNoiseTex,  
	SamplerState PWNoiseTexSampler,
	Texture2D CurlNoiseTex,  
	SamplerState CurlNoiseTexSampler,
	Texture2D HeightLUTTex,  
	SamplerState HeightLUTTexSampler
	)
{
	float DensityAlongCone = 0.0;

	// How wide to make the cone .
	float ConeSpreadMultiplier = LightStepSize;

	noise_kernel[6] = LightDirection;
	// Lighting ray−march loop .
	for(int i  = 0; i <= 6; i++)
	{
		// Add the current step offset to the sample position .
		pos += LightStepSize * LightDirection + (LightStepSize * noise_kernel[i] * float (i));

		if (DensityAlongCone < 0.3)
		{
			// Sample cloud density the expensive way .
			DensityAlongCone += SampleCloudDensity(pos, DensityScale, inCloudMinMax, iTime, WeatherData , MipLevel + 1, false, PWNoiseTex, PWNoiseTexSampler, CurlNoiseTex, CurlNoiseTexSampler, HeightLUTTex, HeightLUTTexSampler);
		}
		else
		{
			// Sample cloud density the cheap way , using only one level of noise .
			DensityAlongCone += SampleCloudDensity(pos, DensityScale, inCloudMinMax, iTime, WeatherData , MipLevel + 1, true, PWNoiseTex, PWNoiseTexSampler, CurlNoiseTex, CurlNoiseTexSampler, HeightLUTTex, HeightLUTTexSampler);
		}
	}

	return DensityAlongCone;
}


#define EPSILON 1e-3

float4 CloudRendering(
	float3 pos, 
	float DensityScale,
	float LightStepSize,
	float3 LightDirection,
	float4 inCloudMinMax, 
	int iTime, 
	float3 WeatherData, 
	float MipLevel,
	float MaxSteps,
	float StepSize,
	Texture3D PWNoiseTex,  
	SamplerState PWNoiseTexSampler,
	Texture2D CurlNoiseTex,  
	SamplerState CurlNoiseTexSampler,
	Texture2D HeightLUTTex,  
	SamplerState HeightLUTTexSampler
)
{
	float Transmittance = 1.0;
	float CloudTest = 0.0;
	int ZeroDensitySampleCount = 0;
	int HitSamples = 0;
	// Start the main ray−march loop .
	for (int i = 0; i < MaxSteps; i++)
	{
		if (Transmittance < 0.001)
		{
			//transmittance = 0;
			//return float4(lightenergy, accum);
			return float4(1, 1, 1, 1 - Transmittance);
		}
		// cloud test starts as zero so we always evaluate the
		// second case from the beginning .
		if (CloudTest > 0.0)
		{
			// Sample density the expensive way, indicating a full sample .
			float SampleDensity = SampleCloudDensity(pos, DensityScale, inCloudMinMax, iTime,  WeatherData, MipLevel , false, PWNoiseTex, PWNoiseTexSampler, CurlNoiseTex, CurlNoiseTexSampler, HeightLUTTex, HeightLUTTexSampler);
			HitSamples++;
			// If we just samples a zero , increment the counter .
			if(EPSILON > abs(SampleDensity))
			{
				ZeroDensitySampleCount ++;
				// If we are doing an expensive sample that is still potentially in the cloud :
				if (ZeroDensitySampleCount != 6)
				{
					// SampleCloudDensityAlongCone just walks in the given direction from the start point and takes X number of lighting samples .
					float DensityAlongLightRay = SampleCloudDensityAlongCone(pos, DensityScale, LightStepSize, LightDirection, inCloudMinMax, iTime, WeatherData, MipLevel, PWNoiseTex, PWNoiseTexSampler, CurlNoiseTex, CurlNoiseTexSampler, HeightLUTTex, HeightLUTTexSampler);
				} 
			}
			else
			{
				float fCurDensity = GetLightTransmittance(SampleDensity * StepSize / 1000.0f);
				Transmittance *= fCurDensity;
			}

		 	// If not potentially in the cloud , then set cloud test to zero so that we go back to the cheap sample case .
			if (6 == ZeroDensitySampleCount)
			{
				CloudTest = 0.0;
				ZeroDensitySampleCount = 0;
			}
			pos += StepSize;
		}
		else
		{
			// Sample density the cheap way , only using the low−frequency noise .
			CloudTest = SampleCloudDensity(pos, DensityScale, inCloudMinMax, iTime, WeatherData, MipLevel , true, PWNoiseTex, PWNoiseTexSampler, CurlNoiseTex, CurlNoiseTexSampler, HeightLUTTex, HeightLUTTexSampler) ;
			if (EPSILON > abs(CloudTest))
			{
				pos += StepSize ;
			}
			else// Hitted, Need to do Another Expensive Sampling At The Same Position
			{
				i--;
			}
			
		}
	}
	return float4(1, 1, 1, 1 - Transmittance);

// return 1;
// }
// #include "/Shaders/VolumetricClouds/VolumetricCloudFunctions.ush"