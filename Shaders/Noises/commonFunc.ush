// Arbitrary random, can be replaced with a function of your choice
float rand(float3 pos, int NoiseTexRes, Texture2D WhiteNoise, SamplerState WhiteNoiseSampler)
{
    float2 uv = pos.xy + pos.z;
	// return Texture2DSample(WhiteNoise, WhiteNoiseSampler, uv).r;
	return Texture2DSample(WhiteNoise, WhiteNoiseSampler, uv / NoiseTexRes).r;
}

float grad3D(float hash, float3 pos) 
{
    float angle = 6.283185 * hash + 4.0 * pos.z * hash;
    return dot(float2(cos(angle), sin(angle)), pos.xy);

    // int h = int(1e4*hash) & 15;
	// float u = h<8 ? pos.x : pos.y,
 	// 	  v = h<4 ? pos.y : h==12||h==14 ? pos.x : pos.z;
    // return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
}

float hash13(float3 pos, int NoiseTexRes, Texture2D WhiteNoise, SamplerState WhiteNoiseSampler)
{
    float2 uv = pos.xy + pos.z;
	return Texture2DSample(WhiteNoise, WhiteNoiseSampler, uv / NoiseTexRes).r;

}

float fade(float t) 
{
    return t;
}

float COSInterpolation(float x,float y,float n)
{
    return lerp(x, y, n);
    // float r = n*3.1415926;
    // float f = (1.0-cos(r))*0.5;
    // return x*(1.0-f)+y*f;
    
}

float perlin(float3 uvw, float SliceNum, float Coverage, int NoiseTexRes, Texture2D WhiteNoise, SamplerState WhiteNoiseSampler)
{
    float3 pi = floor(uvw); 
    float3 pf = uvw - pi;
    
    float u = fade(pf.x);
    float v = fade(pf.y);
    float w = fade(pf.z);

    // SliceNum = 1.0f;
    float3 posOffsetArr[8] = 
    {
        float3(0, 0, 0),
        float3(1.0, 0, 0),
        float3(0, 1.0, 0),
        float3(1.0, 1.0, 0),
        float3(0, 0, 1.0 / SliceNum),
        float3(1.0, 0, 1.0 / SliceNum),
        float3(0, 1.0, 1.0 / SliceNum),
        float3(1.0, 1.0, 1.0 / SliceNum),
    };

    float3 posNoOffsetArr[8] = 
    {
        float3(0.0, 0.0, 0.0),
        float3(1.0, 0.0, 0.0),
        float3(0.0, 1.0, 0.0),
        float3(1.0, 1.0, 0.0),
        float3(0.0, 0.0, 1.0),
        float3(1.0, 0.0, 1.0),
        float3(0.0, 1.0, 1.0),
        float3(1.0, 1.0, 1.0),
    };
    
    return  COSInterpolation( 
                COSInterpolation( 
                    COSInterpolation(
                        grad3D(hash13(pi + posNoOffsetArr[0], NoiseTexRes, WhiteNoise, WhiteNoiseSampler), pf - posOffsetArr[0]),
                        grad3D(hash13(pi + posNoOffsetArr[1], NoiseTexRes, WhiteNoise, WhiteNoiseSampler), pf - posOffsetArr[1]), 
                        u ),
                    COSInterpolation(
                        grad3D(hash13(pi + posNoOffsetArr[2], NoiseTexRes, WhiteNoise, WhiteNoiseSampler), pf - posOffsetArr[2]), 
                        grad3D(hash13(pi + posNoOffsetArr[3], NoiseTexRes, WhiteNoise, WhiteNoiseSampler), pf - posOffsetArr[3]), 
                        u ), 
                    v ),
        		 COSInterpolation( 
                    COSInterpolation( 
                        grad3D(hash13(pi + posNoOffsetArr[4], NoiseTexRes, WhiteNoise, WhiteNoiseSampler), pf - posOffsetArr[4]), 
                        grad3D(hash13(pi + posNoOffsetArr[5], NoiseTexRes, WhiteNoise, WhiteNoiseSampler), pf - posOffsetArr[5]), 
                        u ),
            		COSInterpolation( 
                        grad3D(hash13(pi + posNoOffsetArr[6], NoiseTexRes, WhiteNoise, WhiteNoiseSampler), pf - posOffsetArr[6]), 
                        grad3D(hash13(pi + posNoOffsetArr[7], NoiseTexRes, WhiteNoise, WhiteNoiseSampler), pf - posOffsetArr[7]), 
                        u ), 
                    v ), 
                w ) + Coverage;
}

float perlinFBM(float3 uvw, int firstOctave, int accumOctaves, int iTime, float TimeScale, float SliceNum, float Coverage, int NoiseTexRes, Texture2D WhiteNoise, SamplerState WhiteNoiseSampler)
{
    float sum = 0.0;
    float frequency = pow(2, firstOctave);
	const float persistence = 0.6;
    float amplitude = pow(persistence, firstOctave);
    for(int i=17; i < 17 + 1;i++)
    {
		uvw += iTime * TimeScale;
        sum += perlin(uvw * frequency, SliceNum, Coverage, NoiseTexRes, WhiteNoise, WhiteNoiseSampler) * amplitude;
        frequency *= 2.0;
        amplitude *= persistence;
    }
	return sum;
}

float smooth_step(float r)
{
    if(r<0) 
        return 0;
    else if(r>1) 
        return 1;
    else
        return r*r*r*(10+r*(-15+r*6));
}

float ramp(float r)
{ 
    return smooth_step((r+1)/2)*2-1; 
}

float potential(float3 uvw, int firstOctave, int accumOctaves, int iTime, float TimeScale, float SliceNum, float Coverage, int NoiseTexRes, Texture2D WhiteNoise, SamplerState WhiteNoiseSampler)
{
    return perlinFBM(uvw, firstOctave, accumOctaves, iTime, TimeScale, SliceNum, Coverage, NoiseTexRes, WhiteNoise, WhiteNoiseSampler);
    float x = uvw.x;
    float y = uvw.y;
    
    float background_flow_speed = -0.25;
    float disc_radius = 0.12;
    float disc_influence = 0.25;
    float2 disc = float2(0.7, 0.5);
    float wake_expansion = 0.3;
    float noise_gain[3] = 
    {
        0.03,
        0.03*0.35,
        0.03*0.1
    };
    float noise_lengthscale[3] = 
    {
        0.1f, 0.06, 0.026
    };

    // begin with background laminary flow (adjusted so zero level goes through centre of disc)
    float p = -background_flow_speed * (y - disc.y);
    // modify for disc
    float d = length(float2(x,y));

    if(d < disc_influence)
    {
        p *= ramp(d / disc_influence);
    }
    // add turbulent wake that respects disc
    float wake_x = smooth_step(1 - (x - disc.x) / disc_radius);
    if(wake_x > 0)
    {
        float wake_y = smooth_step(1 - abs(y - disc.y) / (1.5f * disc_radius + wake_expansion * (disc.x - x)));
        if(wake_y > 0)
        {
            float wake = wake_x * wake_y;
            float s = 0;
            for(int i = 0; i < 3; ++i)
            {
                s += ramp( d / noise_lengthscale[i]) * noise_gain[i] * 
                    perlinFBM(float3(( x - background_flow_speed * iTime * TimeScale) / noise_lengthscale[i], y / noise_lengthscale[i], 0), firstOctave, accumOctaves, iTime, TimeScale, SliceNum, Coverage, NoiseTexRes, WhiteNoise, WhiteNoiseSampler);
            }
            p += wake * s;
        }
    }
    return p;
}

// Returns the point in a given cell
float3 get_cell_point(float3 cell, int CellNum, int NoiseTexRes, Texture2D WhiteNoise, SamplerState WhiteNoiseSampler) 
{
	float3 cell_base = cell / CellNum;
	float noise_x = rand(cell.xyz, NoiseTexRes, WhiteNoise, WhiteNoiseSampler);
    float noise_y = rand(cell.yzx, NoiseTexRes, WhiteNoise, WhiteNoiseSampler);
    float noise_z = rand(cell.zxy, NoiseTexRes, WhiteNoise, WhiteNoiseSampler);
    return cell_base + (0.5 + 1.5 * float3(noise_x, noise_y, noise_z)) / CellNum;
}

// https://www.shadertoy.com/view/MstGRl
// Performs worley noise by checking all adjacent cells
// and comparing the distance to their points
float worley(float3 coord, int CellNum, int NoiseTexRes, Texture2D WhiteNoise, SamplerState WhiteNoiseSampler)
{
    float3 cell = floor(coord * CellNum);
    float dist = 10000.0;
    
    // Search in the surrounding 5x5x5 cell block
    for (int x = 0; x < 5; x++) 
	{ 
        for (int y = 0; y < 5; y++) 
		{
			for(int z = 0; z < 5; z++)
			{
				float3 cell_point = get_cell_point(cell + float3(x-2, y-2, z-2), CellNum, NoiseTexRes, WhiteNoise, WhiteNoiseSampler);
				dist = min(dist, length(cell_point - coord));
			}
        }
    }
	
	float3 invCellsNum = float3(1.0 / CellNum, 1.0 / CellNum, 1.0 / CellNum);
	dist /= length(invCellsNum);
    dist = 1.0 - dist;
    return dist;

